
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Wordsi by Fozzie The Beat</title>
  <meta name="author" content="Keith Stevens">

  
  <meta name="description" content="Let&#8217;s say you&#8217;re an amateur zoologist and you&#8217;ve got a bunch of data describing
parliaments of owls, gaggles of geese, peeps of &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://fozziethebeat.github.com/blog/page/2">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="Wordsi by Fozzie The Beat" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href='http://fonts.googleapis.com/css?family=Voces' rel='stylesheet' type='text/css'>

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-315689840']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>



  <script type="text/javascript"
          src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Wordsi by Fozzie The Beat</a></h1>
  
    <h2>A blog about computational semantics, life, and anything else.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:fozziethebeat.github.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">About</a></li>
  <li><a href="/papers.html">Research</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/03/16/making-agglomerative-clustering-run-in-n-2-time/">Making Agglomerative Clustering Run in N^2 Time</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-03-16T17:21:00+09:00" pubdate data-updated="true">Mar 16<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Let&#8217;s say you&#8217;re an amateur zoologist and you&#8217;ve got a bunch of data describing
<a href="http://en.wikipedia.org/wiki/Owl">parliaments of owls</a>, <a href="http://en.wikipedia.org/wiki/Goose">gaggles of geese</a>, <a href="http://en.wikipedia.org/wiki/Chicken">peeps of chickens</a>, and a
<a href="http://en.wikipedia.org/wiki/Jackdaw">train of jackdaws</a> but you don&#8217;t really know that you have these bird types.
All you really have are descriptive features describing each bird like feature
type, beak type, conservation status, feeding preferences, etc.   Using just
this data, you&#8217;d like to find out how many bird species you have and how similar
each group is to the others in a nice graphical fashion like down below.  How
would you do it?</p>

<p><img class="center" src="/images/circularDendrogram.png"></p>

<p>The classic solution to the problem would be to use <a href="http://en.wikipedia.org/wiki/Hierarchical_clustering">Hierarchical Agglomerative
Clustering</a>.  In this case, Agglomerative Clustering would group together
birds that have similar features into hopefully distinct species of birds.  And
there&#8217;s a lot of packages out there that kind of do this for you like <a href="http://www.cs.waikato.ac.nz/ml/weka/">Weka</a>,
<a href="http://scikit-learn.org/stable/">Scikit-Learn</a>, or plain old <a href="http://www.statmethods.net/advstats/cluster.html">R</a>.  However, you&#8217;ve got a <em><em>lot</em></em> of birds
to deal with and these standard packages are just taking <em><em>way</em></em> too long.  Why
are they taking way too long?  Because they&#8217;re doing agglomerative clustering
the slow ways.</p>

<p>So what do they slow ways look like?  Well, pretty much all ways of doing
agglomerative clustering start by building an Affinity Matrix that simply
measures how similar two birds are to each other:</p>

<figure class='code'><figcaption><span>Building the Affinity Matrix</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">val</span> <span class="n">m</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">.</span><span class="n">fill</span><span class="o">(</span><span class="n">numBirds</span><span class="o">,</span> <span class="n">numBirds</span><span class="o">)(</span><span class="mi">0</span><span class="o">)</span>
</span><span class='line'><span class="k">for</span> <span class="o">((</span><span class="n">bird1</span><span class="o">,</span> <span class="n">i</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="n">birds</span><span class="o">.</span><span class="n">zipWithIndex</span><span class="o">;</span>
</span><span class='line'>     <span class="o">(</span><span class="n">bird2</span><span class="o">,</span> <span class="n">j</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="n">birds</span><span class="o">.</span><span class="n">zipWithIndex</span><span class="o">)</span>
</span><span class='line'>    <span class="n">m</span><span class="o">(</span><span class="n">i</span><span class="o">)(</span><span class="n">j</span><span class="o">)</span> <span class="k">=</span> <span class="n">similarityBetween</span><span class="o">(</span><span class="n">bird1</span><span class="o">,</span> <span class="n">bird2</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>This little snippet just compares each bird against all other birds and stores
how &#8220;similar&#8221; they are to each other in terms of their descriptive features.
What next?  Well, you need another data structure to keep track of your bird
groups.  We&#8217;ll do this with just a map from group identifiers to sets of bird
identifiers.  And since this algorithm is named &#8220;agglomerative&#8221;, we gotta
agglomerate things, so we&#8217;ll start by putting every bird in their own bird
group:</p>

<figure class='code'><figcaption><span>Starting off the bird groups</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'>    <span class="c1">// First get each bird and it&#39;s id, then create a tuple holding the bird id</span>
</span><span class='line'>    <span class="c1">// and a set with the bird as the only element.  Then turn this list of</span>
</span><span class='line'>    <span class="c1">// tuples into a map.</span>
</span><span class='line'>    <span class="k">var</span> <span class="n">groupMap</span> <span class="k">=</span> <span class="n">birds</span><span class="o">.</span><span class="n">zipWithIndex</span><span class="o">.</span><span class="n">map</span><span class="o">(</span> <span class="n">birdIndex</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">birdIndex</span><span class="o">.</span><span class="n">_2</span><span class="o">,</span> <span class="nc">Set</span><span class="o">(</span><span class="n">birdIndex</span><span class="o">.</span><span class="n">_1</span><span class="o">))).</span><span class="n">toMap</span>
</span></code></pre></td></tr></table></div></figure>


<p>So that was simple.  Now comes the complicated bits that either lead you to a
slow version, a fairly slow version, or a <em>super</em> slow version of agglomerative
clustering.  Before we do either of these options, let&#8217;s make two
simplifications: let&#8217;s assume we just want the final groups that our bird show
up in and we know how many bird groups we want to find.  Agglomerative
Clustering can give you not only this information, but a whole tree showing how
birds are linked together, but the book-keeping for doing this is tricky and
doesn&#8217;t really affect the issues we&#8217;re focusing on here.  With that out of the
way, what does the <em>super</em> slow method look like?</p>

<figure class='code'><figcaption><span>The Super Slow Agglomerative Clustering</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">while</span> <span class="o">(</span><span class="n">groupMap</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">numClusters</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="n">groupSet</span> <span class="k">=</span> <span class="n">groupMap</span><span class="o">.</span><span class="n">toSet</span>
</span><span class='line'>    <span class="c1">// Find the two most similar groups in our map.</span>
</span><span class='line'>    <span class="k">var</span> <span class="n">bestSim</span> <span class="k">=</span> <span class="mf">0.0</span>
</span><span class='line'>    <span class="k">var</span> <span class="n">bestGroups</span> <span class="k">=</span> <span class="o">(-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span>
</span><span class='line'>    <span class="k">for</span> <span class="o">(</span><span class="nc">Array</span><span class="o">((</span><span class="n">id1</span><span class="o">,</span> <span class="n">birds1</span><span class="o">),</span> <span class="o">(</span><span class="n">id2</span><span class="o">,</span> <span class="n">birds2</span><span class="o">))</span> <span class="k">&lt;-</span> <span class="n">groupSet</span><span class="o">.</span><span class="n">subsets</span><span class="o">(</span><span class="mi">2</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="n">_</span><span class="o">.</span><span class="n">toArray</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>        <span class="c1">// Get the similarity between the two bird groups using the raw</span>
</span><span class='line'>        <span class="c1">// values in m.</span>
</span><span class='line'>        <span class="k">val</span> <span class="n">sim</span> <span class="k">=</span> <span class="n">groupSim</span><span class="o">(</span><span class="n">id1</span><span class="o">,</span> <span class="n">birds1</span><span class="o">,</span> <span class="n">id2</span><span class="o">,</span> <span class="n">birds2</span><span class="o">,</span> <span class="n">m</span><span class="o">)</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">sim</span> <span class="o">&gt;</span> <span class="n">bestSim</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">bestSim</span> <span class="k">=</span> <span class="n">sim</span>
</span><span class='line'>            <span class="n">bestGroups</span> <span class="k">=</span> <span class="o">(</span><span class="n">id1</span><span class="o">,</span> <span class="n">id2</span><span class="o">)</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Now merge the two groups together into a new group</span>
</span><span class='line'>    <span class="k">val</span> <span class="n">newGroup</span> <span class="k">=</span> <span class="n">groupMap</span><span class="o">(</span><span class="n">bestGroups</span><span class="o">.</span><span class="n">_1</span><span class="o">)</span> <span class="o">++</span> <span class="n">groupMap</span><span class="o">(</span><span class="n">bestGroups</span><span class="o">.</span><span class="n">_2</span><span class="o">)</span>
</span><span class='line'>    <span class="c1">// Now remove the two groups from the map</span>
</span><span class='line'>    <span class="n">groupMap</span> <span class="k">=</span> <span class="n">groupMap</span> <span class="o">-</span> <span class="n">bestGroups</span><span class="o">.</span><span class="n">_1</span>
</span><span class='line'>    <span class="n">groupMap</span> <span class="k">=</span> <span class="n">groupMap</span> <span class="o">-</span> <span class="n">bestGroups</span><span class="o">.</span><span class="n">_2</span>
</span><span class='line'>    <span class="c1">// Update the map to store the new group.  Since the old id&#39;s are</span>
</span><span class='line'>    <span class="c1">// removed, we can just re-use one of them without any change.</span>
</span><span class='line'>    <span class="n">groupMap</span> <span class="k">=</span> <span class="n">groupMap</span> <span class="o">++</span> <span class="nc">Map</span><span class="o">((</span><span class="n">bestGroups</span><span class="o">.</span><span class="n">_1</span> <span class="o">-&gt;</span> <span class="n">newGroup</span><span class="o">))</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>That&#8217;s it!  It&#8217;s <em>super</em> simple and <em>super</em> slow.  Why is it so slow?  Well, in
general, you&#8217;ll do the big while loop <code>O(N)</code> times, where N is your number of
birds.  Then the next block of code compares each possible pairing of bird
groups.  Since in general the number of groups is proportional to the number of
birds, this will be <code>O(N^2)</code> comparisons.  Throw these two bits together
and you get a runtime of <code>O(N3)</code>!  When you have 100,000 birds,
<em>that&#8217;s</em> <strong>super</strong> slow.</p>

<p>So what can you do to hasten that up?  Well, the main goal of the big loop
through pairs of groups is to find the most <em>similar</em> pair of bird groups, so an
obvious choice would be to create a priority queue, so let&#8217;s see how that looks:</p>

<figure class='code'><figcaption><span>Agglomerative Clustering, Priority Queue Style</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="c1">// Create a new priority queue that tracks the similarity of two groups and</span>
</span><span class='line'><span class="c1">// their id&#39;s</span>
</span><span class='line'><span class="k">val</span> <span class="n">groupQueue</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">[(</span><span class="kt">double</span>, <span class="kt">int</span>, <span class="kt">int</span><span class="o">)]()</span>
</span><span class='line'><span class="k">val</span> <span class="n">groupSet</span> <span class="k">=</span> <span class="n">groupMap</span><span class="o">.</span><span class="n">toSet</span>
</span><span class='line'><span class="k">for</span> <span class="o">(</span><span class="nc">Array</span><span class="o">((</span><span class="n">id1</span><span class="o">,</span> <span class="n">birds1</span><span class="o">),</span> <span class="o">(</span><span class="n">id2</span><span class="o">,</span> <span class="n">birds2</span><span class="o">))</span> <span class="k">&lt;-</span> <span class="n">groupMap</span><span class="o">.</span><span class="n">subsets</span><span class="o">(</span><span class="mi">2</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="n">_</span><span class="o">.</span><span class="n">toArray</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>    <span class="c1">// Get the similarity between the two bird groups using the raw</span>
</span><span class='line'>    <span class="c1">// values in m.</span>
</span><span class='line'>    <span class="k">val</span> <span class="n">sim</span> <span class="k">=</span> <span class="n">groupSim</span><span class="o">(</span><span class="n">id1</span><span class="o">,</span> <span class="n">birds1</span><span class="o">,</span> <span class="n">id2</span><span class="o">,</span> <span class="n">birds2</span><span class="o">,</span> <span class="n">m</span><span class="o">)</span>
</span><span class='line'>    <span class="n">groupQueue</span><span class="o">.</span><span class="n">enque</span><span class="o">((</span><span class="n">sim</span><span class="o">,</span> <span class="n">id1</span><span class="o">,</span> <span class="n">id2</span><span class="o">))</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">var</span> <span class="n">nextId</span> <span class="k">=</span> <span class="n">groupMap</span><span class="o">.</span><span class="n">size</span>
</span><span class='line'><span class="k">while</span> <span class="o">(</span><span class="n">groupMap</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">numClusters</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="n">best</span> <span class="k">=</span> <span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span>
</span><span class='line'>    <span class="k">do</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">best</span> <span class="k">=</span> <span class="n">p</span><span class="o">.</span><span class="n">dequeue</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">while</span> <span class="o">(</span><span class="n">groupMap</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="n">best</span><span class="o">.</span><span class="n">_2</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">groupMap</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="n">best</span><span class="o">.</span><span class="n">_3</span><span class="o">))</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Now merge the two groups together into a new group</span>
</span><span class='line'>    <span class="k">val</span> <span class="n">newGroup</span> <span class="k">=</span> <span class="n">groupMap</span><span class="o">(</span><span class="n">best</span><span class="o">.</span><span class="n">_1</span><span class="o">)</span> <span class="o">++</span> <span class="n">groupMap</span><span class="o">(</span><span class="n">best</span><span class="o">.</span><span class="n">_2</span><span class="o">)</span>
</span><span class='line'>    <span class="c1">// Now remove the two groups from the map</span>
</span><span class='line'>    <span class="n">groupMap</span> <span class="k">=</span> <span class="n">groupMap</span> <span class="o">-</span> <span class="n">best</span><span class="o">.</span><span class="n">_1</span>
</span><span class='line'>    <span class="n">groupMap</span> <span class="k">=</span> <span class="n">groupMap</span> <span class="o">-</span> <span class="n">best</span><span class="o">.</span><span class="n">_2</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Create a new id for this group.</span>
</span><span class='line'>    <span class="k">val</span> <span class="n">newId</span> <span class="k">=</span> <span class="n">nextId</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Next, add in the similarity between the new group and all existing</span>
</span><span class='line'>    <span class="c1">// groups to the queue.</span>
</span><span class='line'>    <span class="k">for</span> <span class="o">(</span> <span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">group</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="n">groupMap</span> <span class="o">)</span>
</span><span class='line'>        <span class="n">groupQueue</span><span class="o">.</span><span class="n">enqueue</span><span class="o">((</span><span class="n">groupSim</span><span class="o">(</span><span class="n">newId</span><span class="o">,</span> <span class="n">newGroup</span><span class="o">,</span> <span class="n">id</span><span class="o">,</span> <span class="n">group</span><span class="o">,</span> <span class="n">m</span><span class="o">),</span>
</span><span class='line'>                            <span class="n">newId</span><span class="o">,</span> <span class="n">id</span><span class="o">))</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Finally, update the map to store the new group.</span>
</span><span class='line'>    <span class="n">nextId</span> <span class="o">+=</span> <span class="mi">1</span>
</span><span class='line'>    <span class="n">groupMap</span> <span class="k">=</span> <span class="n">groupMap</span> <span class="o">++</span> <span class="o">(</span><span class="n">newId</span><span class="o">-&gt;</span> <span class="n">newGroup</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Now this approach is definitely <em>faster</em> but it&#8217;s also horribly memory
inefficient.  Even if you have an array based priority queue that doesn&#8217;t
allocate any extra memory for each entry other than the tuple being stored, this
approach has one major problem: after every merge step <code>O(N)</code> elements
immediately become invalidated.  Since the two merged groups no longer exist,
any comparison between them and other groups is moot.  However the priority
queue doesn&#8217;t easily permit removing them so they just float around.  This is
precisely why lines 14-16 are in a do while loop that ensures the returned
groups exist.  It&#8217;s highly likely that they wont.  I think we can do better,
both in terms of speed and in terms of memory.  So let&#8217;s blaze through a faster
method in couple of steps.</p>

<p>First, we need to change the setup of the algorithm.  The previous two method
just depended on some simple data structures.  This approach requires two
additional structures for bookkeeping: a way to track chains of nearest
neighbors and a way to track the set of clusters not already a part of the
chain.</p>

<figure class='code'><figcaption><span>Agglomerative Clustering, Blazingly Fast Style Step 1</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="c1">// A mapping from cluster id&#39;s to their point sets.</span>
</span><span class='line'><span class="k">val</span> <span class="n">clusterMap</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">HashSet</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]()</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// A set of clusters to be considered for merging.</span>
</span><span class='line'><span class="k">val</span> <span class="n">remaining</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">[</span><span class="kt">Int</span><span class="o">]()</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Create a cluster for every data point and add it to the cluster map</span>
</span><span class='line'><span class="c1">// and to the examine set.</span>
</span><span class='line'><span class="k">for</span> <span class="o">(</span><span class="n">r</span> <span class="k">&lt;-</span> <span class="mi">0</span> <span class="n">until</span> <span class="n">adj</span><span class="o">.</span><span class="n">size</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">remaining</span><span class="o">.</span><span class="n">add</span><span class="o">(</span><span class="n">r</span><span class="o">)</span>
</span><span class='line'>    <span class="n">clusterMap</span><span class="o">(</span><span class="n">r</span><span class="o">)</span> <span class="k">=</span> <span class="nc">HashSet</span><span class="o">(</span><span class="n">r</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Create a stack to represent the nearest neighbor.  The real source of</span>
</span><span class='line'><span class="c1">// matic</span>
</span><span class='line'><span class="k">val</span> <span class="n">chain</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">[(</span><span class="kt">Double</span>, <span class="kt">Int</span><span class="o">)]()</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Add in a random node from remaining to start the neighbor chain.</span>
</span><span class='line'><span class="n">initializeChain</span><span class="o">(</span><span class="n">chain</span><span class="o">,</span> <span class="n">remaining</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>The <code>clusterMap</code> structure replaces our <code>birdMap</code> but does the same thing, but
the remaining set and the chain stack hold the crux of this approach.  Instead
of trying to find the best link between two clusters, we&#8217;re going to depend on
chains of nearest neighbors, so the first node in the chain could be anything,
but the second node is simply the nearest neighbor to the first node.  To add
the third node, we find the nearest neighbor out of any nodes not in the chain.
We&#8217;ll keep doing this until two nodes in the chain represent reciprocal nearest
neighbors, that is two nodes that are most similar to each other, and no other
nodes in or outside of the chain.  Upon finding these two nodes, we merge them,
immediately.  Then we just repeat the process until we have the desired number
of clusters.  In scala, this turns out to be pretty simple to do:</p>

<figure class='code'><figcaption><span>Agglomerative Clustering, Blazingly Fast Style Step 2</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="c1">// Find the nearest neighbors and merge as soon as recursive nearest</span>
</span><span class='line'><span class="c1">// neighbors are found.</span>
</span><span class='line'><span class="k">while</span> <span class="o">(</span><span class="n">clusterMap</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">numClusters</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="c1">// Get the last link in the chain.</span>
</span><span class='line'>    <span class="k">val</span> <span class="o">(</span><span class="n">parentSim</span><span class="o">,</span> <span class="n">current</span><span class="o">)</span> <span class="k">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">top</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Find the nearest neighbor using the clusters not in the chain</span>
</span><span class='line'>    <span class="c1">// already.</span>
</span><span class='line'>    <span class="k">val</span> <span class="o">(</span><span class="n">linkSim</span><span class="o">,</span> <span class="n">next</span><span class="o">)</span> <span class="k">=</span> <span class="n">findBest</span><span class="o">(</span><span class="n">remaining</span><span class="o">,</span> <span class="n">adj</span><span class="o">,</span> <span class="n">current</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Check the similarity for the best neighbor and compare it to that of</span>
</span><span class='line'>    <span class="c1">// the current node in the chain.  If the neighbor sim is larger, then</span>
</span><span class='line'>    <span class="c1">// the current node and it&#39;s parent aren&#39;t RNNs.  Otherwise, the current</span>
</span><span class='line'>    <span class="c1">// node is RNNs with it&#39;s parent.</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">linkSim</span> <span class="o">&gt;</span> <span class="n">parentSim</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="c1">// The current node to push is more similar to the last node in the</span>
</span><span class='line'>        <span class="c1">// chain, so the last node and the next to last nodes can&#39;t be</span>
</span><span class='line'>        <span class="c1">// reciprocal nearest neighbors.</span>
</span><span class='line'>        <span class="n">chain</span><span class="o">.</span><span class="n">push</span><span class="o">((</span><span class="n">linkSim</span><span class="o">,</span> <span class="n">next</span><span class="o">))</span>
</span><span class='line'>        <span class="n">remaining</span><span class="o">.</span><span class="n">remove</span><span class="o">(</span><span class="n">next</span><span class="o">)</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>        <span class="c1">// The current node is less similar to the last node than the last</span>
</span><span class='line'>        <span class="c1">// node is to it&#39;s predecesor in the chain, so the last two nodes in</span>
</span><span class='line'>        <span class="c1">// the chain are just the kind of nodes we&#39;re looking to merge.</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// Pop the current node from the top. </span>
</span><span class='line'>        <span class="n">chain</span><span class="o">.</span><span class="n">pop</span>
</span><span class='line'>        <span class="c1">// Pop the parent of the best node.</span>
</span><span class='line'>        <span class="k">val</span> <span class="o">(</span><span class="n">_</span><span class="o">,</span> <span class="n">parent</span><span class="o">)</span> <span class="k">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">pop</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// These are the two nodes we&#39;ll be merging.  The node we</span>
</span><span class='line'>        <span class="c1">// found above is left in the remaining set and is essentially</span>
</span><span class='line'>        <span class="c1">// forgotten.</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// Remove the current and parent clusters from the cluster map</span>
</span><span class='line'>        <span class="c1">// and extract the sizes.</span>
</span><span class='line'>        <span class="k">val</span> <span class="o">(</span><span class="n">c1Points</span><span class="o">,</span> <span class="n">c1Size</span><span class="o">)</span> <span class="k">=</span> <span class="n">removeCluster</span><span class="o">(</span><span class="n">clusterMap</span><span class="o">,</span> <span class="n">current</span><span class="o">)</span>
</span><span class='line'>        <span class="k">val</span> <span class="o">(</span><span class="n">c2Points</span><span class="o">,</span> <span class="n">c2Size</span><span class="o">)</span> <span class="k">=</span> <span class="n">removeCluster</span><span class="o">(</span><span class="n">clusterMap</span><span class="o">,</span> <span class="n">parent</span><span class="o">)</span>
</span><span class='line'>        <span class="k">val</span> <span class="n">total</span> <span class="k">=</span> <span class="n">c1Size</span> <span class="o">+</span> <span class="n">c2Size</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// Update the similarity between the new merged cluster and all</span>
</span><span class='line'>        <span class="c1">// other existing clusters.  </span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="n">key</span> <span class="k">&lt;-</span> <span class="n">clusterMap</span><span class="o">.</span><span class="n">keys</span><span class="o">)</span>
</span><span class='line'>            <span class="n">adj</span><span class="o">(</span><span class="n">current</span><span class="o">)(</span><span class="n">key</span><span class="o">)</span> <span class="k">=</span> <span class="n">updatedSimilarity</span><span class="o">(</span>
</span><span class='line'>                <span class="n">adj</span><span class="o">,</span> <span class="n">current</span><span class="o">,</span> <span class="n">c1Size</span><span class="o">,</span> <span class="n">parent</span><span class="o">,</span> <span class="n">c2Size</span><span class="o">,</span> <span class="n">key</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// Replace the mapping from current to now point to the merged</span>
</span><span class='line'>        <span class="c1">// cluster and add current back into the set of remaining</span>
</span><span class='line'>        <span class="c1">// clusters so that it&#39;s compared to nodes in the chain.</span>
</span><span class='line'>        <span class="n">clusterMap</span><span class="o">(</span><span class="n">current</span><span class="o">)</span> <span class="k">=</span> <span class="n">c1Points</span> <span class="o">++</span> <span class="n">c2Points</span>
</span><span class='line'>        <span class="n">remaining</span><span class="o">.</span><span class="n">add</span><span class="o">(</span><span class="n">current</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// If the chain is now empty, re-initialize it.</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">chain</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
</span><span class='line'>            <span class="n">initializeChain</span><span class="o">(</span><span class="n">chain</span><span class="o">,</span> <span class="n">remaining</span><span class="o">)</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>And that&#8217;s it!  By focusing on reciprocal nearest neighbors, the algorithm
merges together clusters that will always be merged, no matter how you find
them.  Furthermore, it&#8217;s remarkably easy and fast to find these nodes.  By
building the chain, the number of things that can go on the chain gets smaller
and smaller.</p>

<p>Oh, but there&#8217;s one other magic trick to making this super fast, and it depends
on how you compute <code>updateSimilarity</code>.  The silly way to do it would be to
traverse all the pairings between nodes in the new cluster and the each other
remaining cluster, but that in itself gets really slow as the clusters grow.
But rather than doing that, <a href="http://onlinelibrary.wiley.com/doi/10.1002/widm.53/full">these folks</a> suggest some recurrence relations
that can be computed in <em>constant time</em>, for any of the existing agglomerative
criteria methods.  Crazy right?  But just crazy enough to work correctly and be
too fast to believe.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/03/04/moral-dilemmas/">Moral Dilemmas</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-03-04T19:03:00+09:00" pubdate data-updated="true">Mar 4<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>What is the nature of a moral dilemma?  How moral can any dilemma be?  Are some
dilemmas inherently moral free or can any problem be cast into some level of a
moral quandary? And if that&#8217;s true, how do you get to this quandary state and
where do you go from there?</p>

<p>These questions have been bubbling around in my mind for the past couple months,
ever since I read a <a href="http://www.nytimes.com/2011/09/13/opinion/if-it-feels-right.html">New York Times Op-Ed post</a> about moral dilemmas and a new
book called <a href="http://www.amazon.com/Lost-Transition-Dark-Emerging-Adulthood/dp/0199828024">&#8220;Lost in Transition&#8221;</a>.  In the NYTimes post, the David Brooks notes
that the authors of &#8220;Lost in Transition&#8221; found that modern high school students
are unequipped to think about things in moral terms.  For instance, The authors
posed some questions to students and said the following:</p>

<blockquote><p>Not many of them have previously given much or any thought to many of the kinds of questions about morality that we asked.</p></blockquote>


<p>I haven&#8217;t read the book in detail, so I can&#8217;t really comment on their full
findings, proposals, or methodology, so I&#8217;m not about to comment on that now.
Instead, I got to asking myself the many questions up above.  In particular, I
wanted to know how I could pose daily activities as moral dilemmas.  I don&#8217;t
often put things into directly moral terms, but I was a Teaching Assistant for
a class focused on Ethics in Engineering, so I <em>should</em> be equipped to do some
pretty solid moral analysis if I apply myself.</p>

<p>So, I&#8217;d like to try and break down some seemingly non-moral problems in totally
moral terms.  And to start, let&#8217;s go with <em>Doing the dishes</em>.</p>

<p>Now, normally, you might look at the task of dishes and think that it&#8217;s just
something you have to do.  Often it&#8217;s a little boring, or even a little
unpleasant based on your cooking forays, but it&#8217;s not too often that people feel
morally <em>conflicted</em> about when and whether or not they do their dishes.  But if
you live with other people and share a common cooking space, I would argue that
it is inherently a moral issue.  Namely, it&#8217;s an issue about acting with empathy.</p>

<p>According to Wikipedia, the world&#8217;s coolest encyclopedia, <em>empathy</em> is defined
as</p>

<blockquote><p>the capacity to recognize and, to some extent, share feelings (such as<br/>    sadness or happiness) that are being experienced by another sentient or<br/>    semi-sentient being</p></blockquote>


<p>So how does empathy relate <em>at all</em> to doing the dishes? Well, by living in an
apartment shared with other people, your actions implicitly affect the
livelihood and wellbeing of others.  So let&#8217;s break down the task of dishes into
two aspects: your choice of actions and the possible affects it can have on
others.   When it comes to doing dishes, there&#8217;s really two choices you can
make:</p>

<ol>
<li>do the dishes</li>
<li>don&#8217;t do the dishes</li>
</ol>


<p>And everyone in the house will likely have one of two reactions to dirty dishes:</p>

<ol>
<li>dirty dishes are not a problem</li>
<li>dirty dishes are frustrating</li>
</ol>


<p>With regards to clean dishes, it&#8217;s fairly safe to assume that everyone enjoys
and appreciates clean dishes, i&#8217;ve certainly not met anyone bothered by a clean
plate or glass.  So how do these reactions connect to whether or not you
should make those dishes sparkly clean?  Well, by leaving dirty dishes you&#8217;re
doing one of two things:</p>

<ol>
<li>you&#8217;re assuming that everyone is ok with dirty dishes</li>
<li>you don&#8217;t about how others feel about dirty dishes</li>
</ol>


<p>I would argue that both cases are a failure in empathy.  By assuming that others
share your same reaction to doing the dishes, you&#8217;re failing to recognize that
others in the house may feel otherwise (first half of our empathy definition).
If for instance, a roommate has a horrible case of OCD and emotionally breakdown
upon the sight of food encrusted dishes, failing to do the dishes may make this
particular person deeply wounded.  And by simply ignoring how other&#8217;s feel about
dishes (the second, sharing, half of empathy), even if you recognize that they
may feel differently, you&#8217;re actively choosing not to share those feelings.</p>

<p>What happens if you <em>do</em> clean the dishes and leave things sparkly, fresh, and
lemon scented?  You&#8217;re still making an assumption about how other&#8217;s feel about
dishes, but you&#8217;re making the most conservative assumption you can; most people
prefer clean dishes so by cleaning you&#8217;re <em>less</em> likely to cause any emotional
breakdowns, or in more normal cases, mild frustration.  Assuming that you like
to be happy, doing the dishes is the only <em>empathy</em> filled action available, it
makes the fewest and most conservative assumptions about what makes others happy.</p>

<p>So that&#8217;s one way to break down the task of dishes into a moral dilemma.  So the
next time you make a mess in the kitchen and ask yourself &#8220;should I clean
those?&#8221;  You can make a handy debate about it.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/02/29/morphological-analysis-made-easy-with-scala/">Morphological Analysis Made Easy With Scala</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-02-29T19:49:00+09:00" pubdate data-updated="true">Feb 29<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Ever since I got involved with distributional semantics, i&#8217;ve been perplexed
about how to handle morphed words, which happens to be just about every noun and
verb in English.  What is a morphed word in English you ask?  It&#8217;s pretty much
any word that&#8217;s been changed to reflect things like past tense, plurality,
ownership, and all those things.  They&#8217;re conjugated verbs and more!  But they
always pose a massive problem in distributional semantics.</p>

<p>Think about it for a second, what&#8217;s the big difference between &#8220;cat&#8221; and &#8220;cats&#8221;?
Not too much, the second is simply saying there are multiple occurrences of a
&#8220;cat&#8221;.  But what do people typically do for distributional semantics?  One of
two bad options: leave the two words as separate things and thus split the
information gained about &#8220;cat&#8221; across two words or stem every word and throw
away something important like the multitude of &#8220;cat&#8221;.  Both seem totally wrong
and unsatisfactory.</p>

<p>So on and off I&#8217;ve searched for a good tool to do morphological analysis for
English.  Ideally, the analyzer could recognize the word &#8220;cats&#8221; and split into
two things: <code>cat</code> and <code>&lt;p&gt;</code> that way you can retain all your information about a
<code>cat</code> and still know that there were a multitude of them when you see &#8220;cats&#8221;.
And for verbs?  You should see the same thing, <code>ran</code> could then become something
like <code>run</code> and <code>&lt;past&gt;</code>&#8221; so that again, you still know everything about running and that
it happened in the past.  But until today, I&#8217;ve never found a tool that does
this both quickly and easily in a usable language.</p>

<p>That all changes today.  Today I found the <a href="http://wiki.apertium.org/wiki/Lttoolbox-java">Lltool-box for Java</a>.  It creates
a large finite state machine for recognizing morphed words and figuring out the
root word, i.e. &#8220;run&#8221; in &#8220;ran&#8221; and &#8220;cat&#8221; in &#8220;cats&#8221;, and how the word was
morphed, i.e. &#8220;run&#8221; for &#8220;ran&#8221; and &#8220;cat&#8221; for &#8220;cats&#8221;.  All you have to do is get a
listing of how words are morphed, load it up until the <a href="http://wiki.apertium.org/wiki/Lttoolbox-java">Lttoolbox-java</a>
system and analyze away your sentences.</p>

<p>So let&#8217;s take a spin on how to do this.  First, you read the wiki instructions
for <a href="http://wiki.apertium.org/wiki/Lttoolbox-java">Lttoolbox-java</a>, download it, and compile it.  Compiling is easy:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>mvn deploy -DskipTests</span></code></pre></td></tr></table></div></figure>


<p>The <code>-DskipTests</code> part seems needed since their unit tests don&#8217;t pass.  But
after that, you can start using the code in your favorite jvm based language.
my personal fave is Scala, so let&#8217;s run with that.  So what next?  Now you
create a <a href="http://en.wikipedia.org/wiki/Finite_state_transducer">Finite State Transducer</a> using a dictionary file and tell it to
analyze words:</p>

<figure class='code'><figcaption><span>Setting up the Finite State Transducer </span><a href='https://gist.github.com/1772752'>Source Gist </a></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="c1">// Create the Finite State Transducer processor.</span>
</span><span class='line'><span class="k">val</span> <span class="n">fstp</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">FSTProcessor</span><span class="o">()</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Load the finite state transducer with the compiled dictionary file.  </span>
</span><span class='line'><span class="n">fstp</span><span class="o">.</span><span class="n">load</span><span class="o">(</span><span class="n">openInFileStream</span><span class="o">(</span><span class="n">args</span><span class="o">(</span><span class="mi">0</span><span class="o">)))</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Setup the trandsducer to do morphological analysis and make sure it&#39;s valid.</span>
</span><span class='line'><span class="n">fstp</span><span class="o">.</span><span class="n">initAnalysis</span>
</span></code></pre></td></tr></table></div></figure>


<p>Now that you have a transducer ready to analyze words, you just feed it stuff like this:</p>

<figure class='code'><figcaption><span>Loading the transducer with input and output </span><a href='https://gist.github.com/1772752'>Source Gist </a></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">val</span> <span class="n">in</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">StringReader</span><span class="o">(</span><span class="s">&quot;cats, dogs and blubber all running quickly!&quot;</span><span class="o">)</span>
</span><span class='line'><span class="k">val</span> <span class="n">out</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">StringWriter</span><span class="o">()</span>
</span><span class='line'><span class="c1">// Do the analysis.</span>
</span><span class='line'><span class="n">fstp</span><span class="o">.</span><span class="n">analysis</span><span class="o">(</span><span class="n">in</span><span class="o">,</span> <span class="n">out</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>You gotta create a reader and writer for their transducer interface.  It&#8217;s
funky, but it still leaves you with a pretty flexible interface.  So now what?
What does the output look like?  If you feed it &#8220;cats, dogs and blubber all
running quickly!&#8221;, the output is pretty ugly at first:</p>

<figure class='code'><figcaption><span>This will never look pretty</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'>^cats/cat<span class="nt">&lt;n&gt;&lt;pl&gt;</span>$^,/,<span class="nt">&lt;cm&gt;</span>$
</span><span class='line'>^dogs/dog<span class="nt">&lt;n&gt;&lt;pl&gt;</span>$
</span><span class='line'>^and/and<span class="nt">&lt;cnjcoo&gt;</span>$
</span><span class='line'>^blubber/*blubber$
</span><span class='line'>^all/all<span class="nt">&lt;adj&gt;</span>/all<span class="nt">&lt;adv&gt;</span>/all<span class="nt">&lt;predet&gt;&lt;sp&gt;</span>/all<span class="nt">&lt;det&gt;&lt;qnt&gt;&lt;pl&gt;</span>/all<span class="nt">&lt;det&gt;&lt;qnt&gt;&lt;sp&gt;</span>/all<span class="nt">&lt;prn&gt;&lt;qnt&gt;&lt;mf&gt;&lt;sp&gt;</span>$
</span><span class='line'>^running/run<span class="nt">&lt;vblex&gt;&lt;ger&gt;</span>/run<span class="nt">&lt;vblex&gt;&lt;pprs&gt;</span>/run<span class="nt">&lt;vblex&gt;&lt;subs&gt;</span>/running<span class="nt">&lt;adj&gt;</span>/running<span class="nt">&lt;n&gt;&lt;sg&gt;</span>$
</span><span class='line'>^quickly/quickly<span class="nt">&lt;adv&gt;</span>$
</span></code></pre></td></tr></table></div></figure>


<p>Beastly no? So i figure that it&#8217;s best to write some regular expressions to
handle all of this.  You&#8217;ll need a couple: one to split up words, one to match
analysed words, one for unrecognized words, and one to split up the tags.  In
scala you can do this pretty easily like this:</p>

<figure class='code'><figcaption><span>Regular Expressions for handling output from Lttoolbox-java </span><a href='https://gist.github.com/1772752'>Source Gist </a></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="c1">// 1: Recognize a fully analyzed word so that they can be tokenized.  In the</span>
</span><span class='line'><span class="c1">// above test case, &quot;cats,&quot; will not be separated by white space so we require</span>
</span><span class='line'><span class="c1">// this more complicated splitting method.</span>
</span><span class='line'><span class="k">val</span> <span class="n">parseRegex</span> <span class="k">=</span> <span class="s">&quot;&quot;&quot;\^.*?\$&quot;&quot;&quot;</span><span class="o">.</span><span class="n">r</span>
</span><span class='line'><span class="c1">// 2: Recognize a word with morphological tags.</span>
</span><span class='line'><span class="k">val</span> <span class="n">morphredRegex</span> <span class="k">=</span> <span class="s">&quot;&quot;&quot;\^(.+?)/(.+?)(&lt;[0-9a-z&lt;&gt;]+&gt;).*\$&quot;&quot;&quot;</span>
</span><span class='line'><span class="c1">// 3: Recognize a word that could not be recognized.  The transducer prepends</span>
</span><span class='line'><span class="c1">// &amp;quot;*&amp;quot; to unrecognized tokens, so we match and eliminate it.</span>
</span><span class='line'><span class="k">val</span> <span class="n">unknownRegex</span> <span class="k">=</span> <span class="s">&quot;&quot;&quot;\^(.+)/\*(.+?)\$&quot;&quot;&quot;</span>
</span><span class='line'><span class="c1">// 4: A regular expression for matching morphological tags.  This is simpler</span>
</span><span class='line'><span class="c1">// than writing a splitting rule.</span>
</span><span class='line'><span class="k">val</span> <span class="n">featureRegex</span> <span class="k">=</span> <span class="s">&quot;&quot;&quot;&lt;.*?&gt;&quot;&quot;&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Then all you need to do is run through the analyzed sentence and split it up
into separate tokens, some for root words and some for morphed features.  You
can do that like this:</p>

<figure class='code'><figcaption><span>Parsing that business Lttoolbox-java </span><a href='https://gist.github.com/1772752'>Source Gist </a></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">val</span> <span class="n">tokens</span> <span class="k">=</span> <span class="n">parseRegex</span><span class="o">.</span><span class="n">findAllIn</span><span class="o">(</span><span class="n">out</span><span class="o">.</span><span class="n">toString</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="n">parseMatch</span> <span class="o">=&amp;</span><span class="n">gt</span><span class="o">;</span>
</span><span class='line'><span class="c1">// Match the current analyzed word as being morphed or unknown.  For morphed</span>
</span><span class='line'><span class="c1">// words, create a list of the lemma and the tags.  For unknown words just</span>
</span><span class='line'><span class="c1">// create a list of the lemma.</span>
</span><span class='line'><span class="n">parseMatch</span><span class="o">.</span><span class="n">toString</span> <span class="k">match</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">morphredRegex</span><span class="o">(</span><span class="n">surface</span><span class="o">,</span> <span class="n">lemma</span><span class="o">,</span> <span class="n">tags</span><span class="o">)</span> <span class="o">=&amp;</span><span class="n">gt</span><span class="o">;</span>
</span><span class='line'>        <span class="n">lemma</span> <span class="o">::</span> <span class="n">featureRegex</span><span class="o">.</span><span class="n">findAllIn</span><span class="o">(</span><span class="n">tags</span><span class="o">).</span><span class="n">toList</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">unknownRegex</span><span class="o">(</span><span class="n">surface</span><span class="o">,</span> <span class="n">lemma</span><span class="o">)</span> <span class="o">=&amp;</span><span class="n">gt</span><span class="o">;</span>
</span><span class='line'>        <span class="nc">List</span><span class="o">(</span><span class="n">lemma</span><span class="o">)</span>
</span><span class='line'><span class="o">}).</span><span class="n">reduceLeft</span><span class="o">(</span><span class="n">_++_</span><span class="o">).</span><span class="n">filter</span><span class="o">(!</span><span class="n">rejectFeatures</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="n">_</span><span class="o">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>This bit of code&#8217;s pretty sweet.  You first iterate over each analyzed word with
the first matcher.  Then you match each word with the two word level regular
expressions: one for fully analyzed words and one for unrecognized words.  After
that it&#8217;s easy smeesy, you just split the tags up with the last regular
expression and turn it all into a list.  The last two bits at the end turn the
whole thing into a single list and lets you filter out tags or tokens you don&#8217;t
want.</p>

<p>So with that, you can now do simple and fast morphological analysis in Java,
Scala, or even Clojure (but who&#8217;d do something silly like that?)!-</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>About Me</h1>
  <p>I&#8217;m working on a PhD centered around Word Sense Induction and Clustering.
      When i&#8217;m not doing research, i&#8217;m volunteering throughout the city.   
  </p>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2012/08/28/finding-events-during-the-olympics/">Finding Events During the Olympics</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/08/12/building-a-phrase-graph/">Building A Phrase Graph</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/08/03/building-visualizations-to-test-summarizations/">Building Visualizations to Test Summarizations</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/07/13/acl-and-emnlp-2012-debrief/">ACL and EMNLP 2012 Debrief</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/06/25/gamma-ramma/">Gamma Ramma</a>
      </li>
    
  </ul>
</section>
<section>
  <h1>Tag Cloud</h1>
    <span id="tag-cloud"><a href='/blog/categories/automation' style='font-size: 108.57142857142857%'>Automation(1)</a> <a href='/blog/categories/bayesian' style='font-size: 108.57142857142857%'>Bayesian(1)</a> <a href='/blog/categories/bayesian-modeling' style='font-size: 117.14285714285714%'>Bayesian modeling(2)</a> <a href='/blog/categories/clustering' style='font-size: 134.28571428571428%'>Clustering(4)</a> <a href='/blog/categories/computational' style='font-size: 108.57142857142857%'>Computational(1)</a> <a href='/blog/categories/computational-linguistics' style='font-size: 108.57142857142857%'>Computational linguistics(1)</a> <a href='/blog/categories/conferences' style='font-size: 108.57142857142857%'>Conferences(1)</a> <a href='/blog/categories/d3' style='font-size: 108.57142857142857%'>D3(1)</a> <a href='/blog/categories/dilemmas' style='font-size: 108.57142857142857%'>Dilemmas(1)</a> <a href='/blog/categories/experiments' style='font-size: 108.57142857142857%'>Experiments(1)</a> <a href='/blog/categories/javascript' style='font-size: 108.57142857142857%'>Javascript(1)</a> <a href='/blog/categories/linguistics' style='font-size: 117.14285714285714%'>Linguistics(2)</a> <a href='/blog/categories/maven' style='font-size: 108.57142857142857%'>Maven(1)</a> <a href='/blog/categories/morality' style='font-size: 108.57142857142857%'>Morality(1)</a> <a href='/blog/categories/natural-language-processing' style='font-size: 108.57142857142857%'>Natural language processing(1)</a> <a href='/blog/categories/natural-language-processing' style='font-size: 117.14285714285714%'>Natural language processing(2)</a> <a href='/blog/categories/open-source' style='font-size: 108.57142857142857%'>Open source(1)</a> <a href='/blog/categories/python' style='font-size: 108.57142857142857%'>Python(1)</a> <a href='/blog/categories/scala' style='font-size: 160.0%'>Scala(7)</a> <a href='/blog/categories/statistics' style='font-size: 108.57142857142857%'>Statistics(1)</a> <a href='/blog/categories/topic-models' style='font-size: 108.57142857142857%'>Topic models(1)</a> </span>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  
  <a href="https://github.com/fozziethebeat">@fozziethebeat</a> on GitHub
  
  <script type="text/javascript">
    $.domReady(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'fozziethebeat',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>


<section>
  <h1>Latest Tweets</h1>
  <ul id="tweets">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  <script type="text/javascript">
    $.domReady(function(){
      getTwitterFeed("fozziethebeat", 4, false);
    });
  </script>
  <script src="/javascripts/twitter.js" type="text/javascript"> </script>
  
    <a href="http://twitter.com/fozziethebeat" class="twitter-follow-button" data-show-count="false">Follow @fozziethebeat</a>
  
</section>


  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2012 - Keith Stevens -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'fozziethebeat';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/all.js#appId=212934732101925&xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>



  <script type="text/javascript">
    (function() {
      var script = document.createElement('script'); script.type = 'text/javascript'; script.async = true;
      script.src = 'https://apis.google.com/js/plusone.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(script, s);
    })();
  </script>



  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>

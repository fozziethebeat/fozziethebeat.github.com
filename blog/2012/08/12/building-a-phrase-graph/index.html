
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Building A Phrase Graph - Wordsi by Fozzie The Beat</title>
  <meta name="author" content="Keith Stevens">

  
  <meta name="description" content="Research papers. I hate them sometimes. They present a great idea, talk about
how it can be used and applied, and then give only the barest &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://fozziethebeat.github.com/blog/2012/08/12/building-a-phrase-graph">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="Wordsi by Fozzie The Beat" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href='http://fonts.googleapis.com/css?family=Voces' rel='stylesheet' type='text/css'>

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-315689840']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>



  <script type="text/javascript"
          src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Wordsi by Fozzie The Beat</a></h1>
  
    <h2>A blog about computational semantics, life, and anything else.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:fozziethebeat.github.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">About</a></li>
  <li><a href="/papers.html">Research</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">Building a Phrase Graph</h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-08-12T12:13:00+09:00" pubdate data-updated="true">Aug 12<span>th</span>, 2012</time>
        
      </p>
    
  </header>


<div class="entry-content"><p>Research papers.  I hate them sometimes.  They present a great idea, talk about
how it can be used and applied, and then give only the barest description of how
to actually build and implement the idea, often with no pointers or links to
what they built.  My current frustration is with building a <strong>Phrase Graph</strong>.
The idea behind phrase graphs are pretty simple, they encode a large set of
sentences with a minimal automata.</p>

<p>Here&#8217;s a simple example.  Say you have the following two sentences:</p>

<pre><code>#archery by the Republic of Korea and the guy is legally blind.
#archery by the Republic of Korea and the guy who is legally blind.
#archery by the Republic of Korea in archery by a guy who is legally blind.
</code></pre>

<p>There&#8217;s quite a lot of overlap at the start of the sentence and at the end of
the sentence.  So a good phrase graph would look something like this:</p>

<p><img src="/images/phrase-graph-example.svg" alt="A simple Phrase Graph" /></p>

<p>So you can see that the nodes in the graph represent words found in the
sentences observed and if you weight the nodes based on how often they are
traversed, you can start to detect which phrases are used most frequently.  But
how does one do this?  And how does one do this efficiently?  This is where
research papers make me mad.  They fail to point out the simplest algorithms for
building these awesome ideas.  To complement these research ideas, this post&#8217;ll
give a little more detail on what these phrase graphs are, an easy way to build
them using existing libraries, and code to write your own custom phrase graph!</p>

<h2>Badly described methods for building a phrase graph</h2>

<p>The first paper I read for building phrase graphs, titled <a href="http://www.jeffreynichols.com/papers/summary-iui2012.pdf">Summarizing Sporting
events using Twitter</a>, gives this highly detailed algorithm description:</p>

<blockquote><p>The phrase graph consists of a node for each word appearing in any status update, and an edge between each set of two words that are used adjacently in any status update</p></blockquote>


<p>Seems easy to implement, no?  Here&#8217;s a more detailed algorithm, found in
<a href="http://www.cs.uccs.edu/~jkalita/papers/2010/SharifiBeauxSocialcom2010.pdf">Experiments in Microblog Summarization</a>:</p>

<blockquote><p>To construct the left-hand side, the algorithm starts with the root node. It reduces the set of input sentences to the set of sentences that contain the current node’s phrase. The current node and the root node are initially the same. Since every input sentence is guaranteed to contain the root phrase, our list of sentences does not change initially. Subsequently, the algorithm isolates the set of words that occur immediately before the current node’s phrase. From this set, duplicate words are combined and assigned a count that represents how many instances of those words are detected. For each of these unique words, the algorithm adds them to the graph as nodes with their associated counts to the left of the current node.</p></blockquote>


<p>This gives a lot more detail on what the phrase graph contains, and an easy
enough algorithm, but it&#8217;s not exactly a <strong>fast</strong> algorithm, especially if you
want to do this using 10 million tweets about the Olympics.  Both descriptions
leave out a key detail: these phrase graphs are really just <a href="http://en.wikipedia.org/wiki/Trie#Compressing_tries">Compressed Tries</a>.</p>

<h2>Tries and their compressed cousins</h2>

<p><img src="http://upload.wikimedia.org/wikipedia/commons/b/be/Trie_example.svg" alt="A simple Trie" /></p>

<p><a href="http://en.wikipedia.org/wiki/Trie#Compressing_tries">Tries</a> are one of the simplest data structures, and one of the most powerful
when processing natural languages.  Given a set of words or sentences, a
<a href="http://en.wikipedia.org/wiki/Trie#Compressing_tries">Trie</a> is essentially a standard tree where the leaves represent observed
words or sentences.  The power of it is that each internal node in the <a href="http://en.wikipedia.org/wiki/Trie#Compressing_tries">Trie</a>
represents overlapping sequences. So if you want to build a <a href="http://en.wikipedia.org/wiki/Trie#Compressing_tries">Trie</a> for an <a href="http://www.brics.dk/automaton/">English
Dictionary</a>, the root node would be a blank character, which then points to a
node for each letter of the alphabet.  From the &#8220;a&#8221; child, you would then have
access to all words starting with &#8220;a&#8221;, and the further down the <a href="http://en.wikipedia.org/wiki/Trie#Compressing_tries">Trie</a> you
go, you get longer prefixes of words.</p>

<p>Now a <em>Phrase Graph</em> is essentially a <a href="http://en.wikipedia.org/wiki/Trie#Compressing_tries">Trie</a> which condenses not only shared
prefixes, but also any shared subsequence, be they in the middle, or the end.
Formally, they are directed acyclic graphs, and if they are treated as a lookup
structure, ala a dictionary, they are called <em>Minimal Acyclic Finite-State
Automata</em>.  And there&#8217;s plenty of fast and simple ways to build these things.
The easiest places to start reading about these is <a href="http://acl.ldc.upenn.edu/J/J00/J00-1002.pdf">Incremental Construction of
Minimal Acyclic Finite State Automata</a>. The <a href="http://www.brics.dk/automaton/">Brics Automaton package</a> also
provides a really good implantation for these that works</p>

<figure class='code'><figcaption><span>A simple example using the Brics package</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">import</span> <span class="nn">dk.brics.automaton.BasicAutomata</span>
</span><span class='line'><span class="k">val</span> <span class="n">automata</span> <span class="k">=</span> <span class="nc">BasicAutomata</span><span class="o">.</span><span class="n">makeStringUnion</span><span class="o">(</span>
</span><span class='line'>    <span class="s">&quot;#archery by the Republic of Korea and the guy is legally blind&quot;</span><span class="o">,</span>
</span><span class='line'>    <span class="s">&quot;#archery by the Republic of Korea in archery by a guy who is legally blind&quot;</span><span class="o">)</span>
</span><span class='line'><span class="n">println</span><span class="o">(</span><span class="n">automata</span><span class="o">.</span><span class="n">toDot</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>The above code snippet will generate this simple minimal automata:</p>

<p><img src="/images/brics-phrase-graph-example.svg" alt="A GraphViz version of the Brics Automata" /></p>

<p>*Note, you may want to open this in a new tab to zoom in as every letter has
it&#8217;s own state.</p>

<h2>Rolling your own automata builder</h2>

<p>Using <a href="http://www.brics.dk/automaton/">Brics</a> works really well if you just want to check whether or not a
sentence matches one seen in a corpus.  However, it doesn&#8217;t easily let you check
how often particular sub-phrases are used within the corpus.  For that kinda
power, you&#8217;ll have to craft your own implemenation.  And now it&#8217;s time to share
the very code to do this!</p>

<h3>Nodes in the graph, that&#8217;s where.</h3>

<p>Where does one start?  First, you need a node data structure, with some very
carefully crafted functions to determine equality (which indidentally, the
research papers <strong>don&#8217;t</strong> point out).</p>

<figure class='code'><figcaption><span>The PhraseNode data structure</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm"> * A simple node structure that records a label, a weight, and a mapping from this node to other nodes using labeled arcs.  This</span>
</span><span class='line'><span class="cm"> * implementation overrides {@link hashCode} and {@link equals} such that only nodes with the same label and which point to the same exact</span>
</span><span class='line'><span class="cm"> * children (i.e.  same objects, not equivalent objects), are considered equal.</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="k">class</span> <span class="nc">PhraseNode</span><span class="o">(</span><span class="k">val</span> <span class="n">label</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * The internal weight for this {@link PhraseNode}.</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="k">var</span> <span class="n">inCount</span> <span class="k">=</span> <span class="mi">0</span><span class="n">d</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * A mapping from this {@link PhraseNode} to children {@link PhraseNode}s using labeled arcs.</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="k">var</span> <span class="n">linkMap</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">[</span><span class="kt">String</span>,<span class="kt">PhraseNode</span><span class="o">]()</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * A record of the last {@link PhraseNode} added as a child to this {@link PhraseNode}.</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="k">var</span> <span class="n">lastAdded</span><span class="k">:</span><span class="kt">PhraseNode</span> <span class="o">=</span> <span class="kc">null</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * Returns the {@link PhraseNode} connected to {@code this} {@link PhraseNode} via the arc {@code term}.  If no such node exists, a new</span>
</span><span class='line'><span class="cm">     * {@link PhraseNode} is created and returned.</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">neighbor</span><span class="o">(</span><span class="n">term</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span>
</span><span class='line'>        <span class="n">linkMap</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">term</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">node</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">node</span>
</span><span class='line'>            <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="o">{</span> <span class="n">lastAdded</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">PhraseNode</span><span class="o">(</span><span class="n">term</span><span class="o">)</span>
</span><span class='line'>                           <span class="n">linkMap</span> <span class="o">+=</span> <span class="o">(</span><span class="n">term</span> <span class="o">-&gt;</span> <span class="n">lastAdded</span><span class="o">)</span>
</span><span class='line'>                           <span class="n">lastAdded</span>
</span><span class='line'>                         <span class="o">}</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * Adds {@code delta} to the {@code inCount} and returns a pointer to {@code this} {@link PhraseNode}.</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">addCount</span><span class="o">(</span><span class="n">delta</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mi">1</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">inCount</span> <span class="o">+=</span> <span class="n">delta</span>
</span><span class='line'>        <span class="k">this</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * Returns a hashcode based on java&#39;s internal hash code method for every object which uniquely identifies every object.</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">pointerHashCode</span> <span class="k">=</span> <span class="k">super</span><span class="o">.</span><span class="n">hashCode</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * Override {@code hashCode} to use three factors:</span>
</span><span class='line'><span class="cm">     * &lt;ol&gt;</span>
</span><span class='line'><span class="cm">     *  &lt;li&gt;The hash code for {@code label}&lt;/li&gt;</span>
</span><span class='line'><span class="cm">     *  &lt;li&gt;The hash code for {@code label} of each child node&lt;/li&gt;</span>
</span><span class='line'><span class="cm">     *  &lt;li&gt;The hash code for {@code pointer} of each child node&lt;/li&gt;</span>
</span><span class='line'><span class="cm">     * &lt;/ol&gt;</span>
</span><span class='line'><span class="cm">     * This ensures that nodes only have the same hash code if they have the same label, same number of children, same links to those</span>
</span><span class='line'><span class="cm">     * children, and point to the very same children.  This is a cheap and fast way to ensure that we don&#39;t accidently consider two nodes</span>
</span><span class='line'><span class="cm">     * with the same link labels aren&#39;t equivalent.</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="k">override</span> <span class="k">def</span> <span class="n">hashCode</span> <span class="k">=</span>
</span><span class='line'>        <span class="n">linkMap</span><span class="o">.</span><span class="n">map</span><span class="o">{</span> <span class="k">case</span><span class="o">(</span><span class="n">childLabel</span><span class="o">,</span> <span class="n">child</span><span class="o">)</span> <span class="k">=&gt;</span>
</span><span class='line'>            <span class="n">childLabel</span><span class="o">.</span><span class="n">hashCode</span> <span class="o">^</span> <span class="n">child</span><span class="o">.</span><span class="n">pointerHashCode</span>
</span><span class='line'>        <span class="o">}.</span><span class="n">foldLeft</span><span class="o">(</span><span class="n">label</span><span class="o">.</span><span class="n">hashCode</span><span class="o">)(</span><span class="n">_^_</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * Override {@code equals} to use the same three factors as {@cod hachCode}:K</span>
</span><span class='line'><span class="cm">     * &lt;ol&gt;</span>
</span><span class='line'><span class="cm">     *  &lt;li&gt;The {@code label}&lt;/li&gt;</span>
</span><span class='line'><span class="cm">     *  &lt;li&gt;The {@code label} of each child node&lt;/li&gt;</span>
</span><span class='line'><span class="cm">     *  &lt;li&gt;The {@code pointer} of each child node&lt;/li&gt;</span>
</span><span class='line'><span class="cm">     * &lt;/ol&gt;</span>
</span><span class='line'><span class="cm">     * </span>
</span><span class='line'><span class="cm">     * This ensures that nodes only equal when they have the same distinguishing meta data and point to the same children.</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="k">override</span> <span class="k">def</span> <span class="n">equals</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span>
</span><span class='line'>        <span class="n">that</span> <span class="k">match</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">case</span> <span class="n">other</span><span class="k">:</span> <span class="kt">PhraseNode</span> <span class="o">=&gt;</span> <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="n">hashCode</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">hashCode</span><span class="o">)</span> <span class="kc">false</span>
</span><span class='line'>                                      <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="n">label</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">label</span><span class="o">)</span> <span class="kc">false</span>
</span><span class='line'>                                      <span class="k">else</span> <span class="n">compareLinkMaps</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="n">linkMap</span><span class="o">,</span> <span class="n">other</span><span class="o">.</span><span class="n">linkMap</span><span class="o">)</span>
</span><span class='line'>            <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">false</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * Returns true if the two maps have the same size, same keys, and the key in each map points to the same object.  We use this instead</span>
</span><span class='line'><span class="cm">     * of simply calling equals between the two maps because we want to check node equality using just the pointer hash code, which prevents</span>
</span><span class='line'><span class="cm">     * walking down the entire graph structure from each node.</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">compareLinkMaps</span><span class="o">(</span><span class="n">lmap1</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">PhraseNode</span><span class="o">],</span> <span class="n">lmap2</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">PhraseNode</span><span class="o">])</span> <span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">lmap1</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">lmap2</span><span class="o">.</span><span class="n">size</span><span class="o">)</span>
</span><span class='line'>            <span class="k">return</span> <span class="kc">false</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span> <span class="o">(</span><span class="n">key1</span><span class="o">,</span> <span class="n">entry1</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="n">lmap1</span> <span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">val</span> <span class="n">matched</span> <span class="k">=</span> <span class="n">lmap2</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">key1</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
</span><span class='line'>                <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">entry2</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">entry2</span><span class="o">.</span><span class="n">pointerHashCode</span> <span class="o">==</span> <span class="n">entry1</span><span class="o">.</span><span class="n">pointerHashCode</span>
</span><span class='line'>                <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="kc">false</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(!</span><span class="n">matched</span><span class="o">)</span>
</span><span class='line'>                <span class="k">return</span> <span class="kc">false</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="kc">true</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>This <code>PhraseNode</code> has three fairly simple data members, a label that records
which word the node represents, the weight of the node, and a map from this node
to it&#8217;s children based on their labels.  The tricky part of this node is how you
determine equality.  Two nodes can be equal in two different senses: 1) they are
the exact same data structure in memory, and so their memory locations are the
same or 2) they have the same label and point to the same exact children in
memory.  Checking the first type of equality is easy, you can compare the hash
code of their addresses using the default <code>hashCode</code> method java provides for
every object.  Checking the second form of equality is more challenging to do
efficiently.  The naive way would be to recursively check that all children
eventually point to sub-graphs with the same structure.  However, checking the
hash code of the pointers of each children is <strong>much</strong> faster and accomplishes
the same goal.  Hence, this is why we override <code>hashCode</code> and <code>equals</code> with such
complicated code.</p>

<h3>Linking together those Phrase Nodes</h3>

<p>The algorithm for linking together <code>PhraseNodes</code> such that they form a minimal
transducer relies on a few interesting tricks and <strong>beautiful</strong> recursion.  The
first trick we need is lexicographically sorted input.  By sorting the input,
you&#8217;re maximizing the size of matching prefixes between any neighboring words you want
to put in the transducer.  So let&#8217;s look at how we do that adding in sorted
order.</p>

<p>Before we get there though, let&#8217;s flesh sketch out a <code>CondensedTrie</code> data
structure.  It&#8217;s pretty simple.  It starts off with just having a single
<code>PhraseNode</code> element, the root.</p>

<figure class='code'><figcaption><span>Not the data structure we deserve, but the data structure we need</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm"> * The {@link CondensedTrie} represents a single phrase graph centered around a single key phrase.  Lists of tokens, representing sentences,</span>
</span><span class='line'><span class="cm"> * can be added to the {@link CondensedTrie} to create a minimal finite state automata which counts the number of times sequences of tokens</span>
</span><span class='line'><span class="cm"> * appear.  Lists must be added in fully sorted order, otherwise the behavior is undefined.  Once the {@link CondensedTrie} has been</span>
</span><span class='line'><span class="cm"> * completed, a sequence of tokens can be used to walk through the {@link CondensedTrie} and count the weight of that particular sequence.</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="k">class</span> <span class="nc">CondensedTrie</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * The root node in the {@link CondensedTrie}.  This always has an emtpy label.</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="k">val</span> <span class="n">root</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">PhraseNode</span><span class="o">(</span><span class="s">&quot;&quot;</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Now comes adding entries.  Since we want a clean and easy to use interface,
we&#8217;ll be defensive and assume the elements aren&#8217;t sorted, but they are already
tokenized, so each element in the given list is a sequence of tokens.   How you
sort thoes beasts is a homework assignment.</p>

<figure class='code'><figcaption><span>Adding elements to the Trie</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm"> * Trains the {@link CondensedTrie} on a list of token sequences.  This list does not have to be sorted and will instead be sorted</span>
</span><span class='line'><span class="cm"> * before any sentences are added.</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="k">def</span> <span class="n">train</span><span class="o">(</span><span class="n">tokenizedSentences</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]])</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">for</span> <span class="o">(</span> <span class="n">tokenizedSentence</span> <span class="k">&lt;-</span> <span class="n">tokenizedSentences</span><span class="o">.</span><span class="n">sortWith</span><span class="o">(</span><span class="nc">Util</span><span class="o">.</span><span class="n">tokenListComparator</span><span class="o">)</span> <span class="o">)</span>
</span><span class='line'>        <span class="n">add</span><span class="o">(</span><span class="n">tokenizedSentence</span><span class="o">)</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="n">linkMap</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>
</span><span class='line'>        <span class="n">replaceOrRegister</span><span class="o">(</span><span class="n">root</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm"> * Adds the list of tokens to this {@link CondensedTrie}.</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="k">def</span> <span class="n">add</span><span class="o">(</span><span class="n">tweet</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="o">(</span><span class="n">lastSharedNode</span><span class="o">,</span> <span class="n">remainingSuffix</span><span class="o">)</span> <span class="k">=</span> <span class="n">computeDeepestCommonNodeAndSuffix</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">tweet</span><span class="o">)</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">lastSharedNode</span><span class="o">.</span><span class="n">linkMap</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>
</span><span class='line'>        <span class="n">replaceOrRegister</span><span class="o">(</span><span class="n">lastSharedNode</span><span class="o">)</span>
</span><span class='line'>    <span class="n">addSuffix</span><span class="o">(</span><span class="n">lastSharedNode</span><span class="o">,</span> <span class="n">remainingSuffix</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm"> * Returns the deepest {@link PhraseNode} in the {@link CondensedTrie} matching the tokens in {@code tweet}.  When a {@link PhraseNode}</span>
</span><span class='line'><span class="cm"> * no longer has an arc matching the first element in {@code tweet}, this returns that {@link PhraseNode} and the remaining tokens in</span>
</span><span class='line'><span class="cm"> * {@code tweet} that cold not be matched.</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="k">def</span> <span class="n">computeDeepestCommonNodeAndSuffix</span><span class="o">(</span><span class="n">node</span><span class="k">:</span> <span class="kt">PhraseNode</span><span class="o">,</span> <span class="n">tweet</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">:</span> <span class="o">(</span><span class="kt">PhraseNode</span><span class="o">,</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">=</span>
</span><span class='line'>    <span class="n">tweet</span> <span class="k">match</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">case</span> <span class="n">head</span><span class="o">::</span><span class="n">tail</span> <span class="k">=&gt;</span> <span class="n">node</span><span class="o">.</span><span class="n">linkMap</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">head</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">child</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span>
</span><span class='line'>                <span class="n">child</span><span class="o">.</span><span class="n">addCount</span><span class="o">()</span>
</span><span class='line'>                <span class="n">computeDeepestCommonNodeAndSuffix</span><span class="o">(</span><span class="n">child</span><span class="o">,</span> <span class="n">tail</span><span class="o">)</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>            <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="n">tweet</span><span class="o">)</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="n">tweet</span><span class="o">)</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm"> * Adds all tokens in {@code tweet} as a branch stemming from {@code node}</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="k">def</span> <span class="n">addSuffix</span><span class="o">(</span><span class="n">node</span><span class="k">:</span> <span class="kt">PhraseNode</span><span class="o">,</span> <span class="n">tweet</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">tweet</span><span class="o">.</span><span class="n">foldLeft</span><span class="o">(</span><span class="n">node</span><span class="o">)(</span> <span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">t</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">n</span><span class="o">.</span><span class="n">neighbor</span><span class="o">(</span><span class="n">t</span><span class="o">).</span><span class="n">addCount</span><span class="o">()</span> <span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>These methods are mostly simple.  <code>addSuffix</code> starts adding links to nodes
starting from some initial point, note that nodes will automatically create a
new node for a word if one doesn&#8217;t already exist.
<code>computeDeepestCommonNodeAndSuffix</code> walks down the Trie starting at the root
consuming each token that has a node and returns the deepest node reachable,
i.e. finds the node with the longest common prefix with a given sequence of
tokens.  Finally adding a single tweet depends on getting the prefix, doing some
magic called <code>replaceOrRegister</code> and then adding the suffix to the last node in
the longest prefix.  So, only question left, what is this registry business?</p>

<p>The registry keeps track of all nodes in the graph after they&#8217;ve been validated.
And what does validation entail?  It involves checking wether or not an existing
node already exists in the registry.  If one does, you simply replace that
duplicate node with the one in the registry.  If no such node exists, in goes
the node.  And this is exactly what <code>replaceOrRegister</code> does.  To do this
efficiently <em>and</em> correctly, we call <code>replaceOrRegister</code> on the last node in our
comment prefix and walk all the way down along the most recently added path,
i.e. the added by the <strong>last</strong> element we added, and then zip up any matching
nodes which correspond to matching suffixes.  By starting at the bottom, we match together end points which have no
children and merge them.</p>

<p>Take our archery example above, all three sentences end with &#8220;is legally blind.&#8221;
After we add the first sentence, there would be a node for each token in the
order of the sentence.  When we add the second sentence and walk down to the
end, we see that &#8220;blind.&#8221; has a duplicate, which we can merge.  Taking one step
backwards, we&#8217;ll see that &#8220;legally&#8221; also has an exact match, where two nodes
with the same label point to the <strong>same exact</strong> node, the node we just merged.
And then thanks to recursion, we keep zipping things along until we get to
&#8220;who&#8221;, which has no exact match, and we can stop zipping.  Walking through an
example like this should make the code below a little clearer.</p>

<figure class='code'><figcaption><span>Should i stay or should i go</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm"> * Recursively walks down the chain of last nodes added starting at {@code node} and then checks if the last child of that node are in the</span>
</span><span class='line'><span class="cm"> * registry.  If an equivalent {@link PhraseNode} matching the last child is in the registry, this replaces the last child with the</span>
</span><span class='line'><span class="cm"> * registry node.  If no matching {@link PhraseNode} exists in the registry, then the last child is added to the registry.</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="k">def</span> <span class="n">replaceOrRegister</span><span class="o">(</span><span class="n">node</span><span class="k">:</span> <span class="kt">PhraseNode</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="c1">// Recursively replace or register the last added child of the current node.</span>
</span><span class='line'>    <span class="k">val</span> <span class="n">child</span> <span class="k">=</span> <span class="n">node</span><span class="o">.</span><span class="n">lastAdded</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">child</span><span class="o">.</span><span class="n">linkMap</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>
</span><span class='line'>        <span class="n">replaceOrRegister</span><span class="o">(</span><span class="n">child</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Get the possible matches for the last child.</span>
</span><span class='line'>    <span class="k">val</span> <span class="n">candidateChildren</span> <span class="k">=</span> <span class="n">register</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">child</span><span class="o">.</span><span class="n">label</span><span class="o">)</span>
</span><span class='line'>    <span class="c1">// Select only the registry node which has an exact match to the last</span>
</span><span class='line'>    <span class="c1">// child.  We can also replace this equivalence check for a subsumption</span>
</span><span class='line'>    <span class="c1">// check later on to condence the trie even more while breaking the</span>
</span><span class='line'>    <span class="c1">// automata contract.</span>
</span><span class='line'>    <span class="n">candidateChildren</span><span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="n">matchMethod</span><span class="o">(</span><span class="n">_</span><span class="o">,</span> <span class="n">child</span><span class="o">))</span> <span class="k">match</span> <span class="o">{</span>
</span><span class='line'>        <span class="c1">// If such a child exists, merge the counts of the last child to the</span>
</span><span class='line'>        <span class="c1">// existing child and link the parent to the existing child.  This</span>
</span><span class='line'>        <span class="c1">// is just a convenient way to match a list, which is what gets</span>
</span><span class='line'>        <span class="c1">// returned by filter</span>
</span><span class='line'>        <span class="k">case</span> <span class="n">existingChild</span> <span class="o">::</span> <span class="n">tail</span> <span class="k">=&gt;</span>
</span><span class='line'>            <span class="n">existingChild</span><span class="o">.</span><span class="n">addCount</span><span class="o">(</span><span class="n">child</span><span class="o">.</span><span class="n">inCount</span><span class="o">)</span>
</span><span class='line'>            <span class="c1">// Make sure to update the most recently added node with the</span>
</span><span class='line'>            <span class="c1">// registry version!</span>
</span><span class='line'>            <span class="n">node</span><span class="o">.</span><span class="n">lastAdded</span> <span class="k">=</span> <span class="n">existingChild</span>
</span><span class='line'>            <span class="n">node</span><span class="o">.</span><span class="n">linkMap</span> <span class="o">+=</span> <span class="o">(</span><span class="n">child</span><span class="o">.</span><span class="n">label</span> <span class="o">-&gt;</span> <span class="n">existingChild</span><span class="o">)</span>
</span><span class='line'>        <span class="c1">// If no chld exists, put the last child in the registery.</span>
</span><span class='line'>        <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">register</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="n">child</span><span class="o">.</span><span class="n">label</span><span class="o">,</span> <span class="n">child</span><span class="o">)</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>And Voila, we now have all the code needed to make a phrase graph!</p>

<p><img src="/images/example.exact.phrase-graph.svg" alt="An exact phrase graph using our example sentences" /></p>

<h3>Tweaking the automata to condense more phrases</h3>

<p>BUT! Suppose you want something more minimal?  Suppose you think it&#8217;s kinda
funny that interjection of &#8220;who&#8221; prevents &#8220;guy SOMETHING OR NOTHING is&#8221; from
being a phrase.  Or you try adding in the sentence</p>

<pre><code>#archery ZOIDBERG by the Republic of Korea and the guy who is legally blind.
</code></pre>

<p>and notice how it creates an entirely new branch for &#8220;the Republic of Korea&#8221;
starting at &#8220;ZOIDBERG&#8221;, thus making the number of times you think you&#8217;ve seen
that phrase dependent on the previous tokens.  Can we fix this?  YES!  All we
have to do is relax our definition of finding a matching element in the registry
to finding a node whose outgoing links are a superset of the most recently added
children.</p>

<p>And since Scala is awesome, we can do this with minimal effort.</p>

<figure class='code'><figcaption><span>Enhancing our Trie to be even more compressed</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">class</span> <span class="nc">CondensedTrie</span><span class="o">(</span><span class="n">useSubsumingMatches</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * The filtering method for determining which candidate node from the register will replace existing children nodes during the</span>
</span><span class='line'><span class="cm">     * compaction phase.</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="k">val</span> <span class="n">matchMethod</span> <span class="k">=</span> <span class="k">if</span> <span class="o">(</span><span class="n">useSubsumingMatches</span><span class="o">)</span> <span class="n">subsumeMatch</span> <span class="k">_</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * Returns true if {@code child} and {@code candidate} are exact matches.</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">exactMatch</span><span class="o">(</span><span class="n">candidate</span><span class="k">:</span> <span class="kt">PhraseNode</span><span class="o">,</span> <span class="n">child</span><span class="k">:</span> <span class="kt">PhraseNode</span><span class="o">)</span> <span class="k">=</span>
</span><span class='line'>        <span class="n">candidate</span> <span class="o">==</span> <span class="n">child</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**</span>
</span><span class='line'><span class="cm">     * Returns true if {@code child} and {@code candidate} have the same label and the links from {@code child} are a subset of the links</span>
</span><span class='line'><span class="cm">     * from {@code candidate}.</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">subsumeMatch</span><span class="o">(</span><span class="n">candidate</span><span class="k">:</span> <span class="kt">PhraseNode</span><span class="o">,</span> <span class="n">child</span><span class="k">:</span> <span class="kt">PhraseNode</span><span class="o">)</span> <span class="k">=</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">candidate</span><span class="o">.</span><span class="n">label</span> <span class="o">!=</span> <span class="n">child</span><span class="o">.</span><span class="n">label</span><span class="o">)</span>
</span><span class='line'>            <span class="kc">false</span>
</span><span class='line'>        <span class="k">else</span>
</span><span class='line'>            <span class="n">child</span><span class="o">.</span><span class="n">linkMap</span><span class="o">.</span><span class="n">map</span><span class="o">{</span> <span class="k">case</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">subchild</span><span class="o">)</span> <span class="k">=&gt;</span>
</span><span class='line'>                <span class="n">candidate</span><span class="o">.</span><span class="n">linkMap</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">key</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
</span><span class='line'>                    <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">otherSubchild</span><span class="o">)</span> <span class="k">if</span> <span class="n">otherSubchild</span><span class="o">.</span><span class="n">pointerHashCode</span> <span class="o">==</span> <span class="n">subchild</span><span class="o">.</span><span class="n">pointerHashCode</span> <span class="k">=&gt;</span> <span class="kc">true</span>
</span><span class='line'>                    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">false</span>
</span><span class='line'>                <span class="o">}</span>
</span><span class='line'>            <span class="o">}.</span><span class="n">foldLeft</span><span class="o">(</span><span class="kc">true</span><span class="o">)(</span><span class="n">_&amp;&amp;_</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>All we had to do was update the contractor to take in a boolean, then create a
new data member that links to one of two comparison functions for pairs of
nodes: 1) an exact matching function, which we would use for a true compressed
trie and 2) a subset matching function, to get our even more compressed
sorta-trie.  If we swap in <code>subsumeMatch</code>, we now get this phrase graph:</p>

<p>Let&#8217;s see how the two versions handle this as input:</p>

<pre><code>Republic of Korea in archery by a guy who is legally blind
#archery by the Republic of Korea and by the guy is legally blind
#archery by the Republic of Korea and the guy is legally blind
#archery by the Republic of Korea in archery by a guy who is legally blind
#archery zoidberg by the Republic of Korea and by the guy is legally blind
#archery zoidberg by the Republic of Korea in archery by a guy who is legally blin
</code></pre>

<p>Using exact Matching:
<img src="/images/test.exact.svg" alt="Using Exact Matching" /></p>

<p>Using link subset Matching:
<img src="/images/test.subsume.svg" alt="Using Subset matching" /></p>

<p>Finally! This second version is <strong>precisely</strong> the data structure those three
original papers were describing.</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Keith Stevens</span></span>

      








  


<time datetime="2012-08-12T12:13:00+09:00" pubdate data-updated="true">Aug 12<span>th</span>, 2012</time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/natural-language-processing/'>natural language processing</a>, <a class='category' href='/blog/categories/scala/'>scala</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  <a href="http://twitter.com/share" class="twitter-share-button" data-url="http://fozziethebeat.github.com/blog/2012/08/12/building-a-phrase-graph/" data-via="fozziethebeat" data-counturl="http://fozziethebeat.github.com/blog/2012/08/12/building-a-phrase-graph/" >Tweet</a>
  
  
  <div class="g-plusone" data-size="medium"></div>
  
  
    <div class="fb-like" data-send="true" data-width="450" data-show-faces="false"></div>
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2012/08/03/building-visualizations-to-test-summarizations/" title="Previous Post: Building Visualizations to Test Summarizations">&laquo; Building Visualizations to Test Summarizations</a>
      
      
    </p>
  </footer>
</article>

  <section>
    <h1>Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
  </section>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Categories</h1>
    <ul id="category-list"><li><a href='/blog/categories/bayesian'>Bayesian (1)</a></li><li><a href='/blog/categories/bayesian-modeling'>Bayesian modeling (2)</a></li><li><a href='/blog/categories/clustering'>Clustering (4)</a></li><li><a href='/blog/categories/computational'>Computational (1)</a></li><li><a href='/blog/categories/computational-linguistics'>Computational linguistics (1)</a></li><li><a href='/blog/categories/conferences'>Conferences (1)</a></li><li><a href='/blog/categories/d3'>D3 (1)</a></li><li><a href='/blog/categories/dilemmas'>Dilemmas (1)</a></li><li><a href='/blog/categories/experiments'>Experiments (1)</a></li><li><a href='/blog/categories/linguistics'>Linguistics (2)</a></li><li><a href='/blog/categories/maven'>Maven (1)</a></li><li><a href='/blog/categories/morality'>Morality (1)</a></li><li><a href='/blog/categories/natural-language-processing'>Natural language processing (2)</a></li><li><a href='/blog/categories/natural-language-processing'>Natural language processing (1)</a></li><li><a href='/blog/categories/open-source'>Open source (1)</a></li><li><a href='/blog/categories/scala'>Scala (7)</a></li><li><a href='/blog/categories/statistics'>Statistics (1)</a></li><li><a href='/blog/categories/topic-models'>Topic models (1)</a></li></ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2012/08/12/building-a-phrase-graph/">Building A Phrase Graph</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/08/03/building-visualizations-to-test-summarizations/">Building Visualizations to Test Summarizations</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/07/13/acl-and-emnlp-2012-debrief/">ACL and EMNLP 2012 Debrief</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/06/25/gamma-ramma/">Gamma Ramma</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/06/04/topic-model-comparisons-how-to-replicate-an-experiment/">Topic Model Comparisons: how to replicate an experiment</a>
      </li>
    
  </ul>
</section>

  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2012 - Keith Stevens -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'fozziethebeat';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://fozziethebeat.github.com/blog/2012/08/12/building-a-phrase-graph/';
        var disqus_url = 'http://fozziethebeat.github.com/blog/2012/08/12/building-a-phrase-graph/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/all.js#appId=212934732101925&xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>



  <script type="text/javascript">
    (function() {
      var script = document.createElement('script'); script.type = 'text/javascript'; script.async = true;
      script.src = 'https://apis.google.com/js/plusone.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(script, s);
    })();
  </script>



  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>

<!DOCTYPE html>
<meta charset="utf-8">
<title>Crossfilter</title>
<style>

@import url(http://fonts.googleapis.com/css?family=Yanone+Kaffeesatz:400,700);

body {
  font-family: "Helvetica Neue";
  margin: 40px auto;
  width: 960px;
  min-height: 2000px;
}

#body {
  position: relative;
}

footer {
  padding: 2em 0 1em 0;
  font-size: 12px;
}

h1 {
  font-size: 96px;
  margin-top: .3em;
  margin-bottom: 0;
}

h1 + h2 {
  margin-top: 0;
}

h2 {
  font-weight: 400;
  font-size: 28px;
}

h1, h2 {
  font-family: "Yanone Kaffeesatz";
  text-rendering: optimizeLegibility;
}

#body > p {
  line-height: 1.5em;
  width: 640px;
  text-rendering: optimizeLegibility;
}

#charts {
  padding: 10px 0;
}

.chart {
  display: inline-block;
  height: 151px;
  margin-bottom: 20px;
}

.reset {
  padding-left: 1em;
  font-size: smaller;
  color: #ccc;
}

.background.bar {
  fill: #ccc;
}

.foreground.bar {
  fill: steelblue;
}

.axis path, .axis line {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}

.axis text {
  font: 10px sans-serif;
}

.brush rect.extent {
  fill: steelblue;
  fill-opacity: .125;
}

.brush .resize path {
  fill: #eee;
  stroke: #666;
}

#hour-chart {
  width: 260px;
}

#cluster-chart {
  width: 600px;
}

#delay-chart {
  width: 230px;
}

#distance-chart {
  width: 420px;
}

#date-chart {
  width: 920px;
}

#summary-list {
  min-height: 1024px;
}

#summary-list .date,
#summary-list .day {
  margin-bottom: .4em;
}

#summary-list .daysummary,
#summary-list .summary {
  line-height: 1.5em;
  background: #eee;
  width: 1024;
  margin-bottom: 1px;
}

#summary-list .early {
  color: green;
}

aside {
  position: absolute;
  left: 740px;
  font-size: smaller;
  width: 220px;
}

</style>

<div id="body">

<h1>Summarizing the Olympics through Twitter</h1>

<h2>Analyzing the tweets as they appear</h2>


<div id="charts">
  <div id="hour-chart" class="chart">
    <div class="title">Time of Day</div>
  </div>
  <div id="cluster-chart" class="chart">
    <div class="title">Cluster</div>
  </div>
  <div id="date-chart" class="chart">
    <div class="title">Date</div>
  </div>
</div>

<aside id="totals"><span id="active">-</span> of <span id="total">-</span> Tweets selected.</aside>

<div id="lists">
  <div id="summary-list" class="list"></div>
</div>

<footer>
  <span style="float:right;">
    Released under the <a href="http://www.apache.org/licenses/LICENSE-2.0.html">Apache License 2.0</a>.
  </span>
  Forked from <a href="http://square.github.com/crossfilter/">Square's Crossfilter example</a>.
</footer>

</div>

<a href="https://github.com/fozziethebeat/fozziethebeat.github.com/tree/master/tweetolympics">
    <img style="position: absolute; top: 0; right: 0; border: 0;"
         src="https://a248.e.akamai.net/assets.github.com/img/e6bef7a091f5f3138b8cd40bc3e114258dd68ddf/687474703a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f7265645f6161303030302e706e67"
         alt="Fork me on GitHub">
</a>

<script src="/javascripts/crossfilter.v1.min.js"></script>
<script src="/javascripts/d3.v2.min.js"></script>
<script>

/**
 * Parses the time string as the number of seconds from the start of the epoch
 * and transforms it into a Date object.
 */
function parseTime(t) {
    return new Date(parseInt(t)*1000);
}

// Various formatters.
var formatNumber = d3.format(",d"),
    formatChange = d3.format("+,d"),
    formatDate = d3.time.format("%B %d, %Y"),
    formatTime = d3.time.format("%I:%M %p");


function barChart() {
    if (!barChart.id) barChart.id = 0;

    var margin = {top: 10, right: 10, bottom: 20, left: 10},
        x,
        y = d3.scale.linear().range([100, 0]),
        id = barChart.id++,
        axis = d3.svg.axis().orient("bottom"),
        brush = d3.svg.brush(),
        brushDirty,
        dimension,
        group,
        round;

    function chart(div) {
        var width = x.range()[1],
            height = y.range()[0];

        y.domain([0, group.top(1)[0].value]);

        div.each(function() {
            var div = d3.select(this),
                g = div.select("g");

    // Create the skeletal chart.
    if (g.empty()) {
      div.select(".title").append("a")
          .attr("href", "javascript:reset(" + id + ")")
          .attr("class", "reset")
          .text("reset")
          .style("display", "none");

      g = div.append("svg")
          .attr("width", width + margin.left + margin.right)
          .attr("height", height + margin.top + margin.bottom)
        .append("g")
          .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

      g.append("clipPath")
          .attr("id", "clip-" + id)
        .append("rect")
          .attr("width", width)
          .attr("height", height);

      g.selectAll(".bar")
          .data(["background", "foreground"])
        .enter().append("path")
          .attr("class", function(d) { return d + " bar"; })
          .datum(group.all());

      g.selectAll(".foreground.bar")
          .attr("clip-path", "url(#clip-" + id + ")");

      g.append("g")
          .attr("class", "axis")
          .attr("transform", "translate(0," + height + ")")
          .call(axis);

      // Initialize the brush component with pretty resize handles.
      var gBrush = g.append("g").attr("class", "brush").call(brush);
      gBrush.selectAll("rect").attr("height", height);
      gBrush.selectAll(".resize").append("path").attr("d", resizePath);
    }

    // Only redraw the brush if set externally.
    if (brushDirty) {
      brushDirty = false;
      g.selectAll(".brush").call(brush);
      div.select(".title a").style("display", brush.empty() ? "none" : null);
      if (brush.empty()) {
        g.selectAll("#clip-" + id + " rect")
            .attr("x", 0)
            .attr("width", width);
      } else {
        var extent = brush.extent();
        g.selectAll("#clip-" + id + " rect")
            .attr("x", x(extent[0]))
            .attr("width", x(extent[1]) - x(extent[0]));
      }
    }

    g.selectAll(".bar").attr("d", barPath);
  });

  function barPath(groups) {
    var path = [],
        i = -1,
        n = groups.length,
        d;
    while (++i < n) {
      d = groups[i];
      path.push("M", x(d.key), ",", height, "V", y(d.value), "h9V", height);
    }
    return path.join("");
  }

  function resizePath(d) {
    var e = +(d == "e"),
        x = e ? 1 : -1,
        y = height / 3;
    return "M" + (.5 * x) + "," + y
        + "A6,6 0 0 " + e + " " + (6.5 * x) + "," + (y + 6)
        + "V" + (2 * y - 6)
        + "A6,6 0 0 " + e + " " + (.5 * x) + "," + (2 * y)
        + "Z"
        + "M" + (2.5 * x) + "," + (y + 8)
        + "V" + (2 * y - 8)
        + "M" + (4.5 * x) + "," + (y + 8)
        + "V" + (2 * y - 8);
  }
}

brush.on("brushstart.chart", function() {
  var div = d3.select(this.parentNode.parentNode.parentNode);
  div.select(".title a").style("display", null);
});

brush.on("brush.chart", function() {
  var g = d3.select(this.parentNode),
      extent = brush.extent();
  if (round) g.select(".brush")
      .call(brush.extent(extent = extent.map(round)))
    .selectAll(".resize")
      .style("display", null);
  g.select("#clip-" + id + " rect")
      .attr("x", x(extent[0]))
      .attr("width", x(extent[1]) - x(extent[0]));
  dimension.filterRange(extent);
});

brush.on("brushend.chart", function() {
  if (brush.empty()) {
    var div = d3.select(this.parentNode.parentNode.parentNode);
    div.select(".title a").style("display", "none");
    div.select("#clip-" + id + " rect").attr("x", null).attr("width", "100%");
    dimension.filterAll();
  }
});

chart.margin = function(_) {
  if (!arguments.length) return margin;
  margin = _;
  return chart;
};

chart.x = function(_) {
  if (!arguments.length) return x;
  x = _;
  axis.scale(x);
  brush.x(x);
  return chart;
};

chart.y = function(_) {
  if (!arguments.length) return y;
  y = _;
  return chart;
};

chart.dimension = function(_) {
  if (!arguments.length) return dimension;
  dimension = _;
  return chart;
};

chart.filter = function(_) {
  if (_) {
    brush.extent(_);
    dimension.filterRange(_);
  } else {
    brush.clear();
    dimension.filterAll();
  }
  brushDirty = true;
  return chart;
};

chart.group = function(_) {
  if (!arguments.length) return group;
  group = _;
  return chart;
};

chart.round = function(_) {
  if (!arguments.length) return round;
  round = _;
  return chart;
};

return d3.rebind(chart, brush, "on");
}

d3.csv("/tweetolympics/tweet.gymnastics.particle.mean.all.splits.json", function(summaries) {
    // Add in types to the summaries.
    summaries.forEach(function(d, i) {
       d.index = i;
       d.group = parseInt(d.Group);
       d.startTime = parseTime(d.StartTime);
       d.meanTime = parseTime(d.MeanTime);
    });

    // A nest operator using the day as a key.
    var nestByDate = d3.nest().key(function(d) { return d3.time.day(d.startTime); });

    // (It's CSV, but GitHub Pages only gzip's JSON at the moment.)
    d3.csv("/tweetolympics/tweet.gymnastics.particle.mean.all.groups.json", function(tweets) {
        // Add in types to the tweets.
        tweets.forEach(function(d, i) {
            d.index = i;
            d.group = parseInt(d.Group);
            d.time = parseDate(d.Date);
            d.date = parseTime(d.Time);
        });
        // A nest operator using the group as a key.
        var nestByGroup = d3.nest().key(function(d) { return d.group; });

        // Create the crossfilter for the relevant dimensions and groups.
        var tweet = crossfilter(tweets),
            all = tweet.groupAll(),
            date = tweet.dimension(function(d) { return d3.time.day(d.date); }),
            dates = date.group(),
            hour = tweet.dimension(function(d) { return d.date.getHours() + d.date.getMinutes() / 60; }),
            hours = hour.group(Math.floor),
            cluster = tweet.dimension(function(d) { return d.group; }),
            clusters = cluster.group();

        var charts = [

            // The first chart tracks the hours of each tweet.  It has the
            // standard 24 hour time range and uses a 24 hour clock.
            barChart().dimension(hour)
                      .group(hours)
                      .x(d3.scale.linear()
                                 .domain([0, 24])
                                 .rangeRound([0, 10 * 24])),

            // The second chart tracks the tweet clusters.  The upper limit is
            // dependent on the number of summaries, which equals the number of
            // clusters. 
            // NB: I'm not sure if a linear scale and the rangeRound stuff makes
            // sense.  This is currently just a hack that at least works.
            barChart().dimension(cluster)
                      .group(clusters)
                      .x(d3.scale.linear()
                                 .domain([0, summaries.length+100])
                                 .rangeRound([0, 10*30])),

            // The third chart tracks the dates of the tweets.  This ranges from
            // the start of the olympics until much further out.  The range setting
            // currently makes no sense to me since the display does not match the
            // range set.  Figuring this out is a TODO.
            barChart().dimension(date)
                      .group(dates)
                      .round(d3.time.day.round)
                      .x(d3.time.scale()
                                .domain([new Date(2012, 6, 26), new Date(2012, 8, 10)])
                                .rangeRound([0, 40 * 20]))
        ];

        // Given our array of charts, which we assume are in the same order as the
        // .chart elements in the DOM, bind the charts to the DOM and render them.
        // We also listen to the chart's brush events to update the display.
        var chart = d3.selectAll(".chart")
                      .data(charts)
                      .each(function(chart) { chart.on("brush", renderAll)
                                                   .on("brushend", renderAll); });

        // Render the initial lists.
        var list = d3.selectAll(".list")
                     .data([summaryList]);

        // Print the total number of tweets.
        d3.selectAll("#total").text(formatNumber(all.value()));

        // Render everything..
        renderAll();

        window.filter = function(filters) {
            filters.forEach(function(d, i) { charts[i].filter(d); });
            renderAll();
        };

        window.reset = function(i) {
            charts[i].filter(null);
            renderAll();
        };

        function summaryList(div) {
            // Map each of the top clusters to their corresponding summaries.
            var clusterSummaries = clusters.top(40).map(function(d) {
                return summaries[d.key-1];
            });

            // Group the summaries by their date.
            var tweetsByGroup = nestByDate.entries(clusterSummaries);

            // For each day's summaries, add them as a table with the date as
            // the header.
            div.each(function() {
              var date = d3.select(this)
                           .selectAll(".date")
                           .data(tweetsByGroup, function(d) { return d.key; });

              date.enter()
                  .append("div")
                  .attr("class", "date")
                  .append("div")
                  .attr("class", "day")
                  .text(function(d) { return formatDate(d.values[0].startTime); });

              date.exit().remove();

              var summary = date.order()
                                .selectAll(".summarylist")
                                .data(function(d) { return d.values; },
                                      function(d) { return d.index; });

              var summaryEnter = summary.enter()
                                        .append("div")
                                        .attr("class", "summarylist");

              summaryEnter.append("div")
                          .attr("class", "summary")
                          .text(function(d) { return d.Summary; });

              summary.exit().remove();

              summary.order();
            });
        }

        // Renders the specified chart or list.
        function render(method) {
            d3.select(this).call(method);
        }

        // Whenever the brush moves, re-rendering everything.
        function renderAll() {
            chart.each(render);
            list.each(render);
            d3.select("#active").text(formatNumber(all.value()));
        }

        // Like d3.time.format, but faster.
        function parseDate(d) {
            return new Date(2001,
                            d.substring(0, 2) - 1,
                            d.substring(2, 4),
                            d.substring(4, 6),
                            d.substring(6, 8));
        }
    });
});

</script>
